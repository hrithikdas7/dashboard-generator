import axios from 'axios';
import { toast } from 'react-toastify';

const PRODUCTION = import.meta.env.VITE_PRODUCTION === 'TRUE';
const GOOGLE_CLIENT_ID = import.meta.env.VITE_GOOGLE_CLIENT_ID;

const STAGE_URL =
  import.meta.env.VITE_USE_PRIMARY_STAGE_URL === 'TRUE'
    ? import.meta.env.VITE_STAGE_URL
    : import.meta.env.VITE_STAGE_TWO_URL;

const BASE_URL = PRODUCTION
  ? import.meta.env.VITE_PRODUCTION_URL
  : (STAGE_URL || '{{apiBaseUrl}}');

let token = '';
let isRefreshing = false;
let refreshPromise: Promise<string | null> | null = null;

export const getAxiosInstance = () => {
  token =
    localStorage.getItem('USER_ACCESS_TOKEN') ??
    sessionStorage.getItem('USER_ACCESS_TOKEN') ??
    '';

  const instance = axios.create({
    baseURL: BASE_URL,
    headers: {
      Accept: 'application/json',
      Authorization: token ? `Bearer ${token}` : '',
    },
  });

  instance.interceptors.request.use(
    (config) => config,
    (error) => Promise.reject(error)
  );

  instance.interceptors.response.use(
    (response) => response,
    async (error) => {
      const { response: { status } = {}, config: originalRequest } = error;

      if (status === 401 && !originalRequest._retry) {
        originalRequest._retry = true;

        if (!isRefreshing) {
          isRefreshing = true;
          refreshPromise = axios
            .post(`${BASE_URL}/token/refresh`, {
              refresh: localStorage.getItem('USER_REFRESH_TOKEN'),
            })
            .then(({ data }) => {
              const { access: newAccessToken, refresh: newRefreshToken } = data;
              localStorage.setItem('USER_ACCESS_TOKEN', newAccessToken);
              localStorage.setItem('USER_REFRESH_TOKEN', newRefreshToken);
              instance.defaults.headers.Authorization = `Bearer ${newAccessToken}`;
              return newAccessToken;
            })
            .catch(() => {
              toast.error('Session expired. Please login again.', {
                toastId: 'auth_error_toast',
              });
              localStorage.clear();

              const isOnLoginPage = window.location.pathname === '/login';
              if (!isOnLoginPage) {
                if (GOOGLE_CLIENT_ID) {
                  const params = new URLSearchParams({
                    response_type: 'code',
                    client_id: GOOGLE_CLIENT_ID,
                    scope:
                      'https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/userinfo.profile',
                    redirect_uri: window.location.origin,
                    prompt: 'select_account',
                  });

                  setTimeout(() => {
                    window.location.href = `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
                  }, 100);
                } else {
                  // Fallback to login page if no Google OAuth configured
                  setTimeout(() => {
                    window.location.href = '/login';
                  }, 100);
                }
              }
              return null;
            })
            .finally(() => {
              isRefreshing = false;
            });
        }

        return refreshPromise!.then((newToken) => {
          if (!newToken) return Promise.reject(error);
          originalRequest.headers.Authorization = `Bearer ${newToken}`;
          return instance(originalRequest);
        });
      }

      return Promise.reject(error);
    }
  );

  return instance;
};

/**
 * Legacy apiClient for backwards compatibility
 */
export const apiClient = {
  get: async <T>(url: string) => {
    const instance = getAxiosInstance();
    return instance.get<T>(url);
  },
  post: async <T>(url: string, data?: unknown) => {
    const instance = getAxiosInstance();
    return instance.post<T>(url, data);
  },
  put: async <T>(url: string, data?: unknown) => {
    const instance = getAxiosInstance();
    return instance.put<T>(url, data);
  },
  patch: async <T>(url: string, data?: unknown) => {
    const instance = getAxiosInstance();
    return instance.patch<T>(url, data);
  },
  delete: async <T>(url: string) => {
    const instance = getAxiosInstance();
    return instance.delete<T>(url);
  },
};

/**
 * Helper to extract error message from axios error
 */
export function getErrorMessage(error: unknown): string {
  if (axios.isAxiosError(error)) {
    const apiError = error.response?.data as { message?: string } | undefined;
    return apiError?.message || error.message || 'An error occurred';
  }
  if (error instanceof Error) {
    return error.message;
  }
  return 'An unexpected error occurred';
}
