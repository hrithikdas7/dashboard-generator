/**
 * {{entity.name}} hooks
 * Generated by Dashboard Generator
 */

import useSWR, { mutate } from 'swr';
import { useState, useCallback } from 'react';
import { apiClient, getErrorMessage } from '@/api/client';
import { API_ENDPOINTS } from '@/api/endpoints';
import type { PaginatedResponse } from '@/types/api';
import type { {{entity.name}}, Create{{entity.name}}Dto, Update{{entity.name}}Dto, {{entity.name}}ListParams } from '@/types/{{entity.slug}}';

/**
 * Fetch {{entity.pluralName}} list with pagination and filtering
 */
export function use{{entity.pluralName}}(params: {{entity.name}}ListParams = {}) {
  const {
    page = 1,
    pageSize = {{entity.listConfig.pageSize}},
    search,
    sort = '{{entity.listConfig.defaultSort.field}}',
    sortDirection = '{{entity.listConfig.defaultSort.direction}}',
    ...filters
  } = params;

  const queryParams = new URLSearchParams({
    page: String(page),
    pageSize: String(pageSize),
    ...(search && { search }),
    ...(sort && { sort }),
    ...(sortDirection && { sortDirection }),
  });

  // Add filters
  Object.entries(filters).forEach(([key, value]) => {
    if (value !== undefined && value !== '') {
      queryParams.set(key, String(value));
    }
  });

  const endpoint = `${API_ENDPOINTS.{{constantCase entity.pluralName}}.LIST}?${queryParams.toString()}`;

  const { data, error, isLoading, isValidating } = useSWR<PaginatedResponse<{{entity.name}}>>(
    endpoint
  );

  return {
    {{camelCase entity.pluralName}}: data?.data ?? [],
    total: data?.total ?? 0,
    page: data?.page ?? page,
    pageSize: data?.pageSize ?? pageSize,
    totalPages: data?.totalPages ?? 0,
    isLoading,
    isValidating,
    isError: !!error,
    error: error ? getErrorMessage(error) : null,
  };
}

/**
 * Fetch single {{entity.name}} by ID
 */
export function use{{entity.name}}(id: string | undefined) {
  const endpoint = id ? API_ENDPOINTS.{{constantCase entity.pluralName}}.DETAIL(id) : null;

  const { data, error, isLoading } = useSWR<{{entity.name}}>(endpoint);

  return {
    {{camelCase entity.name}}: data ?? null,
    isLoading,
    isError: !!error,
    error: error ? getErrorMessage(error) : null,
  };
}

/**
 * {{entity.name}} mutations (create, update, delete)
 */
export function use{{entity.name}}Mutations() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const create{{entity.name}} = useCallback(async (data: Create{{entity.name}}Dto): Promise<{{entity.name}} | null> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await apiClient.post<{{entity.name}}>(
        API_ENDPOINTS.{{constantCase entity.pluralName}}.CREATE,
        data
      );

      // Invalidate list cache
      mutate(
        (key) => typeof key === 'string' && key.startsWith(API_ENDPOINTS.{{constantCase entity.pluralName}}.LIST),
        undefined,
        { revalidate: true }
      );

      return response.data;
    } catch (err) {
      setError(getErrorMessage(err));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const update{{entity.name}} = useCallback(async (id: string, data: Update{{entity.name}}Dto): Promise<{{entity.name}} | null> => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await apiClient.put<{{entity.name}}>(
        API_ENDPOINTS.{{constantCase entity.pluralName}}.UPDATE(id),
        data
      );

      // Invalidate caches
      mutate(API_ENDPOINTS.{{constantCase entity.pluralName}}.DETAIL(id), response.data, { revalidate: false });
      mutate(
        (key) => typeof key === 'string' && key.startsWith(API_ENDPOINTS.{{constantCase entity.pluralName}}.LIST),
        undefined,
        { revalidate: true }
      );

      return response.data;
    } catch (err) {
      setError(getErrorMessage(err));
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const delete{{entity.name}} = useCallback(async (id: string): Promise<boolean> => {
    setIsLoading(true);
    setError(null);

    try {
      await apiClient.delete(API_ENDPOINTS.{{constantCase entity.pluralName}}.DELETE(id));

      // Invalidate caches
      mutate(API_ENDPOINTS.{{constantCase entity.pluralName}}.DETAIL(id), undefined, { revalidate: false });
      mutate(
        (key) => typeof key === 'string' && key.startsWith(API_ENDPOINTS.{{constantCase entity.pluralName}}.LIST),
        undefined,
        { revalidate: true }
      );

      return true;
    } catch (err) {
      setError(getErrorMessage(err));
      return false;
    } finally {
      setIsLoading(false);
    }
  }, []);

  return {
    create{{entity.name}},
    update{{entity.name}},
    delete{{entity.name}},
    isLoading,
    error,
  };
}
